## 进程和线程

1.根本区别：进程是操作系统进行**资源分配**的最小单位，线程是操作系统进行**运算调度**的最小单元。

2.从属关系不同：进程包含线程，线程属于进程

3.开销不同：进程的创建、销毁和切换的开销都远大于线程

4.拥有的资源不同：每个进程有自己的内存和资源，一个进程中的线程会共享这些内存和资源

5.控制和影响力不同：子进程可以影响父进程。而子线程可以影响父线程，如果主线程发生异常会影响所在进程和子线程。

6.CPU利用率不同：进程的CPU利用率较低，因为上下文切换开销较大，而线程的CPU利用率较高，上下文的切换速度快

7.操纵者不同：进程的操纵者一般是操作系统，线程的操纵者一般是编程人员

## 三次握手和四次挥手

### 三次握手

TCP 协议位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采用三次握手策略。

#### 三次握手原理：

第一次握手：客户端发送一个带有 SYN 标志地数据包给服务端；

第二次握手：服务端接收成功后，回传一个带有 SYN/ACK 标志的数据包传递确认信息，表示我收到了；

第三次握手：客户端再回传一个带有 ACK 标志的数据包，表示我知道了，握手结束

![img](https://img-blog.csdnimg.cn/20200829115116478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTA2OTIz,size_16,color_FFFFFF,t_70)

#### 三次握手过程详细说明

1.客户端发送建立 TCP 连接的请求报文，其中报文中包含 seq 序列号，是由发送端随机生成的，并且将报文中的 SYN 字段置为 1，表示需要建立 TCP 连接

2.服务端回复客户端发送的 TCP 连接请求报文，其中包含 seq 序号，是由回复随机端生成的，并且将 SYN 置为1，而且会产生 ACK 字段， ACK 字段数值是在客户端发送过来的序列号 seq 的基础上加 1 进行回复，以便客户端收到信息时，知晓自己的 TCP 建立请求已经得到确认。（SYN=1，ACK=x+1，seq=y，y为随机生成数值）

3.客户端收到服务端发送的 TCP 建立验证请求后，会使自己的序列号加 1 表示，并且再次回复 ACK 验证请求，在服务端发过来的seq 上加 1 进行回复（SYN=1，ACK=y+1，seq=x+1）

小结：TCP 建立连接时，通过三次握手能**防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号**。序列号能够保证数据包不重复、不丢弃和按序传输。(能够确保双方具有发送和接收的能力)

- 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
- 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

### 四次挥手

由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

#### 四次挥手原理

第一次挥手：客户端发送一个 FIN ，用来关闭客户端到服务端的数据传送，客户端进入 FIN_WAIT_1 状态；

第二次挥手：服务端收到 FIN 后，发送一个 ACK 给客户端，确认序号为收到序号 + 1，服务端进入CLOSE_WAIT 状态；

第三次挥手：服务端发送一个 FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK 状态；

第四次挥手：客户端收到 FIN 后，客户端进入 TIME_WAIT 状态，接着发送一个 ACK 给 Server，确认序号为收到序号 +1，服务端进入 CLOSED 状态，完成四次挥手。

其中：FIN 标志位数置1，表示断开 TCP 连接

![img](https://img-blog.csdnimg.cn/20200829121601962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTA2OTIz,size_16,color_FFFFFF,t_70)

1、客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，并且还将报文中的FIN字段置为1，表示需要断开TCP连接。（FIN=1，seq=x，x由客户端随机生成）；

2、服务端会回复客户端发送的TCP断开请求报文，其包含seq序列号，是由回复端随机生成的，而且会产生ACK字段，ACK字段数值是在客户端发过来的seq序列号基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP断开请求已经得到验证。（FIN=1，ACK=x+1，seq=y，y由服务端随机生成）；

3、服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开，服务端会先确保断开前，所有传输到A的数据是否已经传输完毕，一旦确认传输数据完毕，就会将回复报文的FIN字段置1，并且产生随机seq序列号。（FIN=1，ACK=x+1，seq=z，z由服务端随机生成）；

4、客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。（FIN=1，ACK=z+1，seq=h，h为客户端随机生成）至此TCP断开的4次挥手过程完毕。

## TCP  和  UDP

### TCP 是面向连接的，UDP 是面向无连接的

TCP 在通信之前需要进行三次握手，UDP 不需要建立三次握手连接。

具体就是：

在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头，标识是 UDP 协议，然后就传递给网络层

在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不做任何拼接操作

### TCP 是可靠的，UDP 是不可靠的

UDP 通信时候不需要进行建立连接，想发就发，这样的情况肯定是不可靠的。它发送数据也不会关心接收方是否正确收到数据

其次，UDP 是没有拥塞控制的，一直以恒定的速度发送数据。就算网络不好，也不会对发送速率作调整。（远程视频，直播等需要 UDP），实时性要求较高

### TCP是面向[字节流](https://so.csdn.net/so/search?q=字节流&spm=1001.2101.3001.7020)的，UDP是面向报文的

TCP 认为消息是**无**保护消息边界的

UDP 认为消息是**有**保护消息边界的接收方一次只能接收一条独立的消息，所以UDP不会粘包

个人理解：UDP把每个数据包当成一条独立的消息。TCP是根据接收方缓存大小接收最大接收包数

举个例子：有三个数据包，大小分别为2k、4k、6k，如果采用UDP发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用TCP协议发送的话，我们只需要接受方的接收缓存有12k的大小，就可以一次把这3个数据包全部发送完毕，那么就会造成接收方一次会接收不止一条消息，这就是粘包

### TCP只有一对一的传输方式，而UDP不仅可以一对一，还可以一对多，多对多

TCP不能一对多的原因是：TCP通信前要跟一台主机进行三次握手连接，因此TCP不能对多

## cookie 和 session 和  token

Cookie和Session都是在Web开发中常用的技术，它们可以用于在浏览器和服务器之间存储信息。

Cookie是一个存储在客户端（浏览器）中的小文件，由服务器发送到客户端。它通常包含有关用户的信息，例如用户ID、登录凭据等。浏览器将此信息存储在本地，每次向服务器发送请求时，它会自动将cookie信息发送回服务器，以便服务器可以识别用户并提供个性化的服务。

Session是一种在服务器端存储用户数据的机制，它通过一个称为session ID的唯一标识符来识别每个会话。服务器会为每个会话创建一个session ID，并将其发送给客户端，客户端将session ID存储在cookie中或者URL的参数中。当用户与服务器进行交互时，服务器使用session ID来查找相关的会话数据，以便提供个性化的服务。

因此，Cookie和Session之间的联系是，Cookie通常用于存储在客户端的用户信息，而Session则用于在服务器端存储用户数据。当使用Session时，服务器通常会将session ID存储在cookie中，以便在后续的请求中可以识别会话，并从服务器中检索相关的数据。

### 使用session 的时候一定会用到cookie吗

通常情况下，使用Session时需要使用Cookie来存储会话ID。服务器会将会话ID存储在Cookie中，并在后续的请求中检查该Cookie以识别用户的会话。

虽然在某些情况下，也可以使用其他机制来传输会话ID，例如在URL中将会话ID作为参数传递。但是，使用Cookie作为传输机制更为常见，因为它更方便和可靠。在大多数情况下，浏览器默认启用Cookie，因此使用Cookie来存储会话ID会更加方便。

总之，虽然使用Session时不一定必须使用Cookie，但是使用Cookie来存储会话ID是一种常见的、方便的方式。

### cookie 和 token 的不同和相同点

Cookie和Token都是在Web开发中常用的身份验证和授权机制，它们的主要作用是识别用户并验证其身份。

相同点：

1. 都是在客户端存储的机制，用于保存用户信息。
2. 都用于验证和授权用户，以限制用户访问某些资源或执行某些操作。
3. 都可以通过加密算法来保护用户的信息安全。

不同点：

1. 存储位置不同：Cookie存储在浏览器中，而Token通常存储在客户端（例如LocalStorage或SessionStorage）或服务器端。
2. 机制不同：Cookie是在浏览器和服务器之间交换的HTTP标头，而Token是一种自包含的字符串，其中包含了有关用户身份验证和授权的所有信息。
3. 操作方式不同：对于Cookie，服务器将在响应头中设置Cookie，浏览器会将其存储在本地并在后续的请求中发送回服务器。而对于Token，客户端在进行请求时需要在请求头中包含Token信息。
4. 可扩展性不同：Token比Cookie更灵活，可以自定义其有效载荷，并支持在服务器和客户端之间进行传递。

总的来说，Cookie和Token都有其适用的场景和优缺点，开发者可以根据实际需要和安全需求选择其中一种或同时使用两种机制来实现身份验证和授权。

### localStorage 和 sessionStorage 的区别

localStorage和sessionStorage都是HTML5提供的客户端存储机制，它们可以用于在浏览器中存储数据。

它们之间的区别如下：

1. 存储生命周期不同：localStorage中存储的数据没有过期时间，只有在用户手动清除浏览器缓存或使用JavaScript代码删除该数据时才会被删除；而sessionStorage中存储的数据仅在当前会话（即浏览器窗口关闭前）有效，一旦浏览器窗口关闭，存储在其中的数据就会被删除。
2. 存储大小限制不同：localStorage和sessionStorage都有存储大小的限制，但是不同浏览器可能有不同的大小限制。通常情况下，localStorage的容量比sessionStorage更大，因为localStorage通常用于持久性存储，而sessionStorage只用于会话级别的临时存储。
3. 数据作用域不同：localStorage中存储的数据在同一个域名下的所有页面中都可以访问；而sessionStorage中存储的数据仅在创建它的窗口中有效，也就是说，即使是同一个域名下的不同页面也不能共享sessionStorage中的数据。

总之，localStorage和sessionStorage都是用于在浏览器中存储数据的机制，它们的主要区别在于存储生命周期、存储大小限制和数据作用域方面。开发者应根据实际需求来选择合适的存储机制。

# HTTP 篇

## HTTP 常见面试题

### HTTP 基本概念

#### HTTP是什么？

HTTP 是一个用在计算机世界里的**协议**。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（**两个以上的参与者**），以及相关的各种控制和错误处理方式（**行为约定和规范**）。

HTTP 是一个在计算机世界里专门用来在**两点之间传输数据**的约定和规范。

HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。

**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

#### HTTP 常见状态码

![ 五大类 HTTP 状态码 ](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png)

- 「**304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。
- 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。

#### HTTP 常见字段有哪些？

*Host* 字段

客户端发送请求时，用来指定服务器的域名。

*Content-Length 字段*

服务器在返回数据时，会有 `Content-Length` 字段，表明本次回应的数据长度。大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，**HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题**。

*Connection 字段*

`Connection` 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。HTTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 `Connection` 首部字段的值为 `Keep-Alive`。

```text
Connection: Keep-Alive
```

*Content-Type 字段*

`Content-Type` 字段用于服务器回应时，告诉客户端，本次数据是什么格式。

```text
Content-Type: text/html; Charset=utf-8
```

上面的类型表明，发送的是网页，而且编码是UTF-8。

客户端请求的时候，可以使用 `Accept` 字段声明自己可以接受哪些数据格式。

```text
Accept: */*
```

上面代码中，客户端声明自己可以接受任何格式的数据。

*Content-Encoding 字段*

`Content-Encoding` 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/11-content-encoding%E5%AD%97%E6%AE%B5.png)

```text
Content-Encoding: gzip
```

上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。

客户端在请求时，用 `Accept-Encoding` 字段说明自己可以接受哪些压缩方法。

```text
Accept-Encoding: gzip, deflate
```

### GET 和 POST 的区别

GET 的语义是请求获取指定的资源。GET 方法是**安全、幂等、可被缓存**的。

POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST **不安全，不幂等，（大部分实现）不可缓存**。

### HTTP 缓存技术

**协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。

当缓存的副本过期时，客户端无法确定缓存的副本是否仍然是最新的版本。

当缓存的副本过期时，以下是客户端的行为：

1. 客户端发送带有缓存验证条件的请求：客户端会在请求中包含条件字段，如`If-None-Match`（用于ETag验证）或`If-Modified-Since`（用于最后修改时间验证）。这些条件字段的值通常是之前获取的缓存副本的相关信息。
2. 服务器进行缓存验证：当服务器接收到带有缓存验证条件的请求后，会使用这些条件与当前资源进行比较。如果资源未更改，服务器将返回304 Not Modified响应。
3. 客户端使用缓存的副本或更新的资源：如果服务器返回304 Not Modified响应，客户端将知道缓存的副本仍然是最新的，并继续使用该副本。如果服务器返回的是更新的资源，客户端将获取到最新的资源并使用它。
4. 如果服务器返回完整的响应：在某些情况下，即使缓存的副本过期，服务器也可能返回完整的响应而不是304 Not Modified响应。这通常发生在缓存被意外删除或缓存机制出现问题的情况下。在这种情况下，客户端将接收到完整的响应，并使用该响应来更新缓存。

总结来说，当缓存的副本过期时，客户端会向服务器发送带有缓存验证条件的请求，服务器会进行验证并返回相应的响应。客户端根据服务器的响应来决定是否继续使用缓存的副本或获取更新的资源。这样可以确保客户端获取到最新的资源，并保持与服务器端的数据同步。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/http%E7%BC%93%E5%AD%98.png)

### HTTP 特性

#### HTTP/1.1 的优点有哪些

1. **简单** HTTP 基本的报文格式就是 header + body，头部信息就是 key-value 的简单文本的形式，易于理解，降低了学习和使用的门槛

2. **灵活和易于扩展** HTTP 协议里面的各类请求方法、状态码、头字段等各个组成要求都没有固定死，都允许开发人员自定义和补充
3. **应用广泛和跨平台** http 天然具有跨平台的优越性

#### HTTP/1.1 的缺点有哪些

*不安全*

HTTP 比较严重的缺点就是不安全：

- 通信使用明文（不加密），内容可能会被窃听。比如，**账号信息容易泄漏，那你号没了。**
- 不验证通信方的身份，因此有可能遭遇伪装。比如，**访问假的淘宝、拼多多，那你钱没了。**
- 无法证明报文的完整性，所以有可能已遭篡改。比如，**网页上植入垃圾广告，视觉污染，眼没了。**

HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。

#### HTTP 的性能如何

HTTP 协议是基于 TCP/IP ，并且使用了请求-应答的通信模式

1. 长连接

   早期 http/1.0 没有建立长连接，每一次发送请求都需要建立一次 TCP 连接，http/1.1 提出了长连接的通信方式，也叫持久连接。这种连接方式的好处在于减少了 TCP 连接重复建立和断开的额外开销，减轻了服务器端的负载

2. 管道网络传输

   http/1.1 采用了长连接的方式，这使得管道网络传输成为可能

   http/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞

3. 队头阻塞

   「请求 - 应答」的模式会造成 HTTP 的性能问题。为什么呢？

   因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「**队头阻塞**」，好比上班的路上塞车。

### HTTP 和 HTTPS

#### 两者的区别

1. HTTPS 比较安全，在 TCP 和 HTTP 网络层之间加入了 SSL/TSL 安全协议，使得报文能够加密传输
2. HTTP 建立比较简单，TCP 三次握手之后即可进行报文传输。而 HTTPS 在三次握手之后，还需要进行 SSL/TLS 的握手
3. 两者默认的端口不一样，http 是 80 ，https 是 443
4. https 协议需要向 CA （证书权威机构）申请数字证书，来保证服务器的身份是可信的

#### HTTPS 解决了 HTTP 哪些问题

HTTP 由于是明文传输，所以安全存在问题

1. 窃听风险----http 的通信内容可以被获取
2. 篡改风险----比如强制植入垃圾广告
3. 冒充（伪造）风险，比如冒充淘宝网站

HTTP**S** 在 HTTP 与 TCP 层之间加入了 `SSL/TLS` 协议，可以很好的解决了上述的风险：

1. 信息加密：交互信息无法获取-----混合加密的方式实现了信息的机密性，解决了窃听的风险
2. 校验机制：无法篡改通信内容，篡改了就无法正常显示-----摘要算法的方式实现完整性，它的原理大概是该算法为数据生成独一无二的指纹，接收方拿到数据后再生成一遍，如果生成后指纹跟发送过来的指纹相同，则校验了数据的完整性，解决了篡改的风险。但是无法保证【内容 + 哈希值】不被篡改
3. 身份证书：证明这个服务器是合法的，将服务器公钥放入到数字证书中，解决了冒充的风险



## HTTP/1.1  如何优化？

总结

这次主要从 3 个方面介绍了优化 HTTP/1.1 协议的思路。

第一个思路是，**通过缓存技术来避免发送 HTTP 请求**。客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。

第二个思路是，**减少 HTTP 请求的次数**，有以下的方法：

1. 将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数；
2. 将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗；
3. 按需访问资源，只访问当前用户看得到/用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。

第三思路是，**通过压缩响应资源，降低传输资源的大小**，从而提高传输效率，所以应当选择更优秀的压缩算法。

不管怎么优化 HTTP/1.1 协议都是有限的，不然也不会出现 HTTP/2 和 HTTP/3 协议，后续我们再来介绍 HTTP/2 和 HTTP/3 协议。

## HTTP2 牛逼在哪里？

无论对 HTTP/1.1 怎样优化，一些关键的地方是无法优化的，比如**请求-响应模型、头部巨大且重复、并发连接耗时、服务器不能主动推送**，要改变这些必须重新设计 HTTP 协议，于是 HTTP/2 就出来了。

### HTTP2 能够 兼容 HTTP/1.1

### 头部压缩

HTTP/1.1 报文中 Header 部分存在的问题

- 包含很多固定字段，例如 cookie，Accept 这些，有必要压缩
- 大量的请求和响应报文字段都是重复的，这样会导致带宽被冗余的数据占据，有必要避免重复性
- 字段是 ASCII 编码的，有必要改成二进制编码

### 二进制帧

### 并发传输

### 服务器主动推送资源



# 常见网络状态码

1xx（信息）：表示接收到请求，需要继续处理。

- 100 Continue：继续，客户端应继续其请求。

2xx（成功）：表示请求已成功被服务器接收、理解和接受。

- 200 OK：请求成功，请求所希望的响应头或数据体将随此响应返回。
- 201 Created：请求已成功，并因此创建了一个新的资源。
- 204 No Content：无内容，服务器成功处理，但未返回内容。

3xx（重定向）：需要后续操作才能完成这一请求。

- 301 Moved Permanently：永久重定向，请求的资源已被永久移动到新位置。
- 302 Found：临时重定向，请求的资源临时从不同位置响应。
- 304 Not Modified：资源未修改，使用缓存的资源。

4xx（客户端错误）：请求包含错误语法或无法完成。

- 400 Bad Request：客户端请求的语法错误，服务器无法理解。
- 401 Unauthorized：请求需要用户验证。
- 403 Forbidden：服务器理解请求客户端的请求，但是拒绝执行它。
- 404 Not Found：请求的资源无法在服务器上找到。

5xx（服务器错误）：服务器未能实现合法的请求。

- 500 Internal Server Error：服务器内部错误，无法完成请求。
- 501 Not Implemented：服务器不支持请求的功能。
- 503 Service Unavailable：服务器暂不可用，可能是服务器过载或停机维护。

# TCP 篇

## 为什么每次建立 TCP 连接时，初始化的序列号都要求一样呢？

1. 为了防止历史报文被下一个相同四元组的连接接收（主要方面）
2. 为了安全性，防止黑客伪造相同序列号的 TCP 报文被对方接收

## 什么是 SYN 攻击？如何避免 SYN 攻击？

![正常流程](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230622886.png)

正常流程：

- 当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；
- 接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；
- 服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；
- 应用通过调用 `accpet()` socket 接口，从「 Accept 队列」取出连接对象。

不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。

SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样**当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃**，导致客户端无法和服务端建立连接。

避免 SYN 攻击方式，可以有以下四种方法：

- 调大 netdev_max_backlog；
- 增大 TCP 半连接队列；
- 开启 tcp_syncookies；
- 减少 SYN+ACK 重传次数

## TCP 和 UDP 有什么区别？分别的应用场景是？

UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务。

### 1. 连接

TCP 是面向连接的传输层协议，传输数据前要先建立连接。

UDP 不需要连接，即刻传输数据。

### 2. 服务对象

TCP 是一对一的两点服务，即一条连接只有两个端点。

UDP 支持一对一，一对多，多对多的交互通信。

### 3. 可靠性

TCP 是可靠交付数据的，数据可以无差错，不丢失，不重复，按序到达。

UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP传输协议实现一个可靠的传输协议。

### 4. 拥塞控制、流量控制

TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。

UDP 则没有，即使网络非常拥堵，也不会影响 UDP 的发送速率。

### 5. 首部开销

TCP 首部长度较长，会有一定的开销，首部在没有使用选项字段时是 20 个字节，如果使用了 选项 字段则会变长

UDP 首部只有 8 个字节，并且是固定不变的，开销较小

### 6. 传输方式

TCP 是流式传输的，没有边界，但保证顺序和可靠。

UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序

### 7. 分片不同

- TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
- UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层

