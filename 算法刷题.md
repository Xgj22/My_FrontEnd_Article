# 重建二叉树

https://www.nowcoder.com/exam/oj/ta?tpId=13?tag=578)

## 描述

给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。

例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。

![img](https://uploadfiles.nowcoder.com/images/20210717/557336_1626504921458/776B0E5E0FAD11A6F15004B29DA5E628)

提示:

1.vin.length == pre.length

2.pre 和 vin 均无重复元素

3.vin出现的元素均出现在 pre里

4.只需要返回根结点，系统会自动输出整颗树做答案对比

数据范围：�≤2000*n*≤2000，节点的值 −10000≤���≤10000−10000≤*v**a**l*≤10000

要求：空间复杂度 �(�)*O*(*n*)，时间复杂度 �(�)*O*(*n*)

```js
/* function TreeNode(x) {
    this.val = x;
    this.left = null;
    this.right = null;
} */
function reConstructBinaryTree(pre, vin)
{
    // write code here
    if(!pre.length){
        return null
    }
    const root = new TreeNode(pre[0])
    let flag = 0
    for(let i = 0;i<vin.length;i++){
        if(vin[i]===root.val){
             flag = i
             break
        }
    }
    root.left = reConstructBinaryTree(pre.slice(1,flag+1),vin.slice(0,flag))
    root.right = reConstructBinaryTree(pre.slice(flag+1,pre.length),vin.slice(flag+1,vin.length))
    return root
}
module.exports = {
    reConstructBinaryTree : reConstructBinaryTree
};
```

slice 方法：`slice()` 方法用于从数组中提取指定范围的元素，并将其返回为新数组。它接受两个参数 `start` 和 `end`，用于指定要提取的元素范围。即使 start 参数超过数组的长度也不会报错，只会返回空数组

# 代码随想录算法训练

## 算法训练第一天 

### 移除链表元素

![image-20230813222321080](C:\Users\XGJ\AppData\Roaming\Typora\typora-user-images\image-20230813222321080.png)

这一题主要是要创建一个虚拟头节点，并且创建一个临时结点用来遍历链表

当临时节点的数值等于 val 时，cur.next = cur.next.next，移除掉链表元素，否则则临时节点继续向后移动

### 反转链表

![image-20230813222739148](C:\Users\XGJ\AppData\Roaming\Typora\typora-user-images\image-20230813222739148.png)

利用双指针 pre 和 cur 分别指向前后两个节点，通过 temp 保存 cur.next，然后进行翻转操作

## 算法训练第二天

### 两两交换链表中的节点

![image-20230813224121309](C:\Users\XGJ\AppData\Roaming\Typora\typora-user-images\image-20230813224121309.png)

这道题还是要设立一个虚拟头节点，交换两个节点的关键在于需要拿到被交换两个节点的前一个节点（cur），循环的条件是cur.next!==null && cur.next.next !==null，交换步骤如下，遇到交换节点的题目还是先把交换步骤写好比较好

![image-20230813224552058](C:\Users\XGJ\AppData\Roaming\Typora\typora-user-images\image-20230813224552058.png)

## 二叉树的中序遍历（迭代法）

```js
var inorderTraversal = function(root, res = []) {
    const stack = [];
    let cur = root;
    // 当栈为空且当前节点为空时，表示遍历完成。
    while(stack.length || cur) {
        if(cur) {
            stack.push(cur);
            // 左
            cur = cur.left;
        } else {
            // --> 弹出 中
            cur = stack.pop();
            res.push(cur.val); 
            // 右
            cur = cur.right;
        }
    };
    return res;
};

```





